Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    AS
    ASSERT
    ASYNC
    AWAIT
    BOOL
    BREAK
    CASE
    CATCH
    CLASS
    CLOSE_KEYS
    CLOSE_PARENTHESES
    COMMA
    CONST
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DIFFERENT
    DIVIDE
    DIVIDEINT
    DIVIDE_EQUAL
    DO
    DOUBLE
    DYNAMIC
    ELSE
    ENUM
    EQUAL
    EQUAL_EQUAL
    EXPORT
    EXPRESS
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FALSE
    FINAL
    FINALLY
    FLOAT
    FOR
    FUNCTION
    GET
    GREATER_THAN
    GREATER_THAN_OR_EQUAL_TO
    HIDE
    IMPLEMENTS
    IMPORT
    IN
    INT
    INTERFACE
    INVERT
    IS
    LESS_THAN
    LESS_THAN_OR_EQUAL_TO
    LIBRARY
    LIST
    LOGIC_AND
    LOGIC_OR
    MAP
    MINUS
    MINUS_EQUAL
    MINUS_MINUS
    MIXIN
    MULT
    MULTIPLICATION_DIVISION
    NEW
    NULL
    NUM
    ON
    OPEN_KEYS
    OPEN_PARENTHESES
    OPERATOR
    OR
    PART
    PERCENTAGE
    PLUS_EQUAL
    PLUS_PLUS
    POINT_COMMA
    POINT_V
    RETHROW
    RETURN
    SET
    SHIFT_LEFT
    SHIFT_RIGHT
    SHOW
    STATIC
    STRING
    STRING_LITERAL
    SUPER
    SWITCH
    SYNC
    THIS
    THROW
    TRUE
    TRY
    TYPEDEF
    UNARY_BITWASE_COMPLEMENT
    VAR
    VOID
    WHILE
    WITH
    XOR
    YIELD

Grammar

Rule 0     S' -> topLevelDeclaration
Rule 1     topLevelDeclaration -> PLUS
Rule 2     topLevelDeclaration -> IF

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
AS                   : 
ASSERT               : 
ASYNC                : 
AWAIT                : 
BOOL                 : 
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
CLOSE_KEYS           : 
CLOSE_PARENTHESES    : 
COMMA                : 
CONST                : 
CONTINUE             : 
COVARIANT            : 
DEFAULT              : 
DEFERRED             : 
DIFFERENT            : 
DIVIDE               : 
DIVIDEINT            : 
DIVIDE_EQUAL         : 
DO                   : 
DOUBLE               : 
DYNAMIC              : 
ELSE                 : 
ENUM                 : 
EQUAL                : 
EQUAL_EQUAL          : 
EXPORT               : 
EXPRESS              : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 
FINAL                : 
FINALLY              : 
FLOAT                : 
FOR                  : 
FUNCTION             : 
GET                  : 
GREATER_THAN         : 
GREATER_THAN_OR_EQUAL_TO : 
HIDE                 : 
IF                   : 2
IMPLEMENTS           : 
IMPORT               : 
IN                   : 
INT                  : 
INTERFACE            : 
INVERT               : 
IS                   : 
LESS_THAN            : 
LESS_THAN_OR_EQUAL_TO : 
LIBRARY              : 
LIST                 : 
LOGIC_AND            : 
LOGIC_OR             : 
MAP                  : 
MINUS                : 
MINUS_EQUAL          : 
MINUS_MINUS          : 
MIXIN                : 
MULT                 : 
MULTIPLICATION_DIVISION : 
NEW                  : 
NULL                 : 
NUM                  : 
ON                   : 
OPEN_KEYS            : 
OPEN_PARENTHESES     : 
OPERATOR             : 
OR                   : 
PART                 : 
PERCENTAGE           : 
PLUS                 : 1
PLUS_EQUAL           : 
PLUS_PLUS            : 
POINT_COMMA          : 
POINT_V              : 
RETHROW              : 
RETURN               : 
SET                  : 
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHOW                 : 
STATIC               : 
STRING               : 
STRING_LITERAL       : 
SUPER                : 
SWITCH               : 
SYNC                 : 
THIS                 : 
THROW                : 
TRUE                 : 
TRY                  : 
TYPEDEF              : 
UNARY_BITWASE_COMPLEMENT : 
VAR                  : 
VOID                 : 
WHILE                : 
WITH                 : 
XOR                  : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

topLevelDeclaration  : 0

Parsing method: LALR

state 0

    (0) S' -> . topLevelDeclaration
    (1) topLevelDeclaration -> . PLUS
    (2) topLevelDeclaration -> . IF

    PLUS            shift and go to state 2
    IF              shift and go to state 3

    topLevelDeclaration            shift and go to state 1

state 1

    (0) S' -> topLevelDeclaration .



state 2

    (1) topLevelDeclaration -> PLUS .

    $end            reduce using rule 1 (topLevelDeclaration -> PLUS .)


state 3

    (2) topLevelDeclaration -> IF .

    $end            reduce using rule 2 (topLevelDeclaration -> IF .)

